import gradio as gr
import subprocess
import re
import glob
import threading
import os
import shutil
import sys
import time
import requests
import json
import urllib.parse
from datetime import date
import platform
import tarfile
import tempfile

# å…¨å±€æ ‡å¿—ï¼Œæ ‡è®°åç«¯æœåŠ¡æ˜¯å¦å·²å¯åŠ¨
backend_ready = False
backend_failed = False
BACKEND_BASE_URL = os.getenv("BACKEND_BASE_URL", "http://127.0.0.1:13579").rstrip("/")
NODE_MIN_MAJOR = int(os.getenv("NODE_MIN_MAJOR", "18"))

# è®¾ç½®ç¯å¢ƒå˜é‡ï¼Œå¼ºåˆ¶ä¸èµ°ä»£ç†
os.environ["NO_PROXY"] = "localhost,127.0.0.1"


def backend_url(path):
    if not path.startswith("/"):
        path = "/" + path
    return f"{BACKEND_BASE_URL}{path}"


def backend_healthcheck(base_url, timeout=3):
    try:
        response = requests.get(f"{base_url}/api/ip", timeout=timeout)
        return response.status_code == 200
    except Exception:
        return False

def amap_request(url, params, timeout=10):
    try:
        response = requests.get(url, params=params, timeout=timeout)
        if response.status_code != 200:
            return None
        return response.json()
    except Exception:
        return None


def amap_place_around(location, types_code, radius=5000, limit=6):
    api_key = os.getenv("AMAP_API_KEY", "").strip()
    if not api_key:
        return []
    params = {
        "key": api_key,
        "location": location,
        "types": types_code,
        "radius": radius,
        "sortrule": "distance",
        "offset": limit,
        "page": 1,
        "extensions": "all",
    }
    data = amap_request("https://restapi.amap.com/v3/place/around", params)
    if not data or data.get("status") != "1":
        return []
    return data.get("pois", []) or []


def normalize_amap_poi(poi):
    name = poi.get("name")
    if not name:
        return None
    address = poi.get("address") or ""
    distance = poi.get("distance") or ""
    category = poi.get("type") or ""
    biz = poi.get("biz_ext") or {}
    rec = {
        "name": name,
        "address": address,
        "distance": distance,
        "type": category,
    }
    rating = biz.get("rating")
    cost = biz.get("cost")
    if rating or cost:
        rec["business"] = {}
        if rating:
            rec["business"]["rating"] = rating
        if cost:
            rec["business"]["cost"] = cost
    return rec


def fallback_recommendation(preference, types_list, origin, latitude, longitude):
    location = f"{longitude},{latitude}"
    results = []
    seen = set()
    for t in types_list:
        pois = amap_place_around(location, t, radius=5000, limit=6)
        for poi in pois:
            rec = normalize_amap_poi(poi)
            if not rec:
                continue
            key = rec.get("name")
            if key in seen:
                continue
            seen.add(key)
            results.append(rec)
            if len(results) >= 8:
                break
        if len(results) >= 8:
            break

    if not results:
        results = [
            {
                "name": "Team Building Venue",
                "address": origin or "",
                "distance": "",
                "type": "",
            }
        ]

    return {
        "recommendations": results,
        "reason": "Generated by Python fallback (no Node.js backend).",
    }


def parse_time_to_minutes(value, default_minutes):
    try:
        parts = value.split(":")
        if len(parts) != 2:
            return default_minutes
        hour = int(parts[0])
        minute = int(parts[1])
        return hour * 60 + minute
    except Exception:
        return default_minutes


def minutes_to_time(value):
    value = max(0, int(value))
    hour = value // 60
    minute = value % 60
    return f"{hour:02d}:{minute:02d}"


def fallback_teamplan(plan_name, people_count, budget_range, start_time, end_time, start_location, latitude, longitude):
    per_capita = 0
    if isinstance(budget_range, (list, tuple)) and budget_range:
        if len(budget_range) == 1:
            per_capita = float(budget_range[0])
        else:
            per_capita = sum(budget_range) / len(budget_range)
    elif isinstance(budget_range, (int, float)):
        per_capita = float(budget_range)

    location = f"{longitude},{latitude}"
    activity_pois = amap_place_around(location, "080000", radius=8000, limit=4)
    food_pois = amap_place_around(location, "050000", radius=8000, limit=4)

    activities = []
    if activity_pois:
        rec = normalize_amap_poi(activity_pois[0])
        if rec:
            activities.append({
                "name": rec.get("name"),
                "type": "activity",
                "address": rec.get("address", ""),
                "description": "Nearby activity venue",
            })
    if food_pois:
        rec = normalize_amap_poi(food_pois[0])
        if rec:
            activities.append({
                "name": rec.get("name"),
                "type": "food",
                "address": rec.get("address", ""),
                "description": "Nearby dining option",
            })
    if len(activities) < 2 and activity_pois:
        rec = normalize_amap_poi(activity_pois[-1])
        if rec:
            activities.append({
                "name": rec.get("name"),
                "type": "activity",
                "address": rec.get("address", ""),
                "description": "Team activity",
            })

    if not activities:
        activities = [
            {
                "name": "Team Building",
                "type": "activity",
                "address": start_location or "",
                "description": "Fallback plan",
            }
        ]

    start_min = parse_time_to_minutes(start_time or "09:00", 9 * 60)
    end_min = parse_time_to_minutes(end_time or "18:00", 18 * 60)
    if end_min <= start_min:
        end_min = start_min + 8 * 60

    slot = max(60, (end_min - start_min) // max(len(activities), 1))
    for idx, act in enumerate(activities):
        s = start_min + idx * slot
        e = min(end_min, s + slot)
        act["timeRange"] = {"start": minutes_to_time(s), "end": minutes_to_time(e)}

    return {
        "title": plan_name or "Team Building Plan",
        "budgetInfo": {
            "perCapitaCost": int(per_capita) if per_capita else None,
            "totalBudget": int(per_capita * people_count) if per_capita else None,
            "activityCount": len(activities),
        },
        "activities": activities,
        "isMultiDay": False,
    }


def format_recommendation_result(result_data):
    """
    ç¾åŒ–æ¨èç»“æœçš„æ˜¾ç¤ºæ ¼å¼
    """
    if isinstance(result_data, str):
        # å¦‚æœæ˜¯å­—ç¬¦ä¸²ï¼Œå°è¯•è§£æä¸ºJSON
        try:
            result_data = json.loads(result_data)
        except:
            return result_data
    
    if isinstance(result_data, dict):
        formatted = "# ğŸ¯ æ¨èç»“æœ\n\n"
        
        # å¦‚æœæœ‰POIæ¨èåˆ—è¡¨
        if "pois" in result_data or "recommendations" in result_data:
            pois = result_data.get("pois") or result_data.get("recommendations", [])
            
            if pois:
                formatted += "## ğŸ“ æ¨èåœ°ç‚¹\n\n"
                for idx, poi in enumerate(pois, 1):
                    formatted += f"### {idx}. {poi.get('name', 'æœªçŸ¥åœ°ç‚¹')}\n\n"
                    
                    # åŸºæœ¬ä¿¡æ¯
                    if poi.get('address'):
                        formatted += f"ğŸ“ **åœ°å€**: {poi['address']}\n\n"
                    
                    if poi.get('distance'):
                        formatted += f"ğŸš— **è·ç¦»**: {poi['distance']}\n\n"
                    
                    if poi.get('duration'):
                        formatted += f"â±ï¸ **é€šå‹¤æ—¶é—´**: {poi['duration']}\n\n"
                    
                    # è¯„åˆ†å’Œä»·æ ¼ - ä» business å¯¹è±¡ä¸­è¯»å–
                    if poi.get('business'):
                        business = poi['business']
                        if business.get('rating'):
                            rating = business['rating']
                            try:
                                stars = "â­" * int(float(rating))
                                formatted += f"â­ **è¯„åˆ†**: {rating} {stars}\n\n"
                            except:
                                formatted += f"â­ **è¯„åˆ†**: {rating}\n\n"
                        if business.get('cost'):
                            cost = str(business['cost']).rstrip('0').rstrip('.') if '.' in str(business['cost']) else str(business['cost'])
                            formatted += f"ğŸ’° **äººå‡æ¶ˆè´¹**: Â¥{cost}\n\n"
                    elif poi.get('rating'):
                        try:
                            stars = "â­" * int(float(poi['rating']))
                            formatted += f"â­ **è¯„åˆ†**: {poi['rating']} {stars}\n\n"
                        except:
                            formatted += f"â­ **è¯„åˆ†**: {poi['rating']}\n\n"
                    
                    if not poi.get('business') and (poi.get('price') or poi.get('avgPrice')):
                        price = poi.get('price') or poi.get('avgPrice')
                        formatted += f"ğŸ’° **äººå‡æ¶ˆè´¹**: Â¥{price}\n\n"
                    
                    # ç±»å‹å’Œæ ‡ç­¾
                    if poi.get('type') or poi.get('category'):
                        category = poi.get('type') or poi.get('category')
                        formatted += f"ğŸ·ï¸ **ç±»å‹**: {category}\n\n"
                    
                    if poi.get('tags'):
                        tags = poi['tags']
                        if isinstance(tags, list):
                            tags_str = " Â· ".join(tags)
                        else:
                            tags_str = str(tags)
                        formatted += f"ğŸ”– **æ ‡ç­¾**: {tags_str}\n\n"
                    
                    # æè¿°
                    if poi.get('description'):
                        formatted += f"ğŸ“ **ç®€ä»‹**: {poi['description']}\n\n"
                    
                    # è”ç³»æ–¹å¼
                    if poi.get('phone') or poi.get('tel'):
                        phone = poi.get('phone') or poi.get('tel')
                        formatted += f"ğŸ“ **ç”µè¯**: {phone}\n\n"
                    
                    # è¥ä¸šæ—¶é—´
                    if poi.get('openTime') or poi.get('businessHours'):
                        hours = poi.get('openTime') or poi.get('businessHours')
                        formatted += f"ğŸ• **è¥ä¸šæ—¶é—´**: {hours}\n\n"
                    
                    formatted += "---\n\n"
            else:
                formatted += "æš‚æ— æ¨èåœ°ç‚¹\n\n"
        
        # å¦‚æœæœ‰æ¨èç†ç”±
        if "reason" in result_data or "recommendation_reason" in result_data:
            reason = result_data.get("reason") or result_data.get("recommendation_reason")
            formatted += f"## ğŸ’¡ æ¨èç†ç”±\n\n{reason}\n\n"
        
        # å¦‚æœæœ‰æ€»ç»“
        if "summary" in result_data:
            formatted += f"## ğŸ“Š æ¨èæ€»ç»“\n\n{result_data['summary']}\n\n"
        
        # å¦‚æœæœ‰è·¯çº¿è§„åˆ’
        if "route" in result_data or "itinerary" in result_data:
            route = result_data.get("route") or result_data.get("itinerary")
            formatted += f"## ğŸ—ºï¸ è¡Œç¨‹è§„åˆ’\n\n{route}\n\n"
        
        # å…¶ä»–ä¿¡æ¯
        other_keys = set(result_data.keys()) - {
            'pois', 'recommendations', 'reason', 'recommendation_reason', 
            'summary', 'route', 'itinerary'
        }
        
        if other_keys:
            formatted += "## â„¹ï¸ å…¶ä»–ä¿¡æ¯\n\n"
            for key in other_keys:
                value = result_data[key]
                formatted += f"**{key}**: {value}\n\n"
        
        return formatted
    
    # å¦‚æœæ˜¯åˆ—è¡¨
    elif isinstance(result_data, list):
        formatted = "# ğŸ¯ æ¨èç»“æœ\n\n"
        for idx, item in enumerate(result_data, 1):
            if isinstance(item, dict):
                formatted += f"## {idx}. {item.get('name', f'æ¨è {idx}')}\n\n"
                formatted += format_dict_item(item)
                formatted += "\n---\n\n"
            else:
                formatted += f"{idx}. {str(item)}\n\n"
        return formatted
    
    # å…¶ä»–æƒ…å†µï¼Œè¿”å›åŸå§‹æ ¼å¼
    return str(result_data)


def format_dict_item(item_dict):
    """æ ¼å¼åŒ–å­—å…¸é¡¹"""
    formatted = ""
    
    # å›¾æ ‡æ˜ å°„
    icon_map = {
        'name': 'ğŸ“',
        'address': 'ğŸ ',
        'distance': 'ğŸ“',
        'duration': 'â±ï¸',
        'rating': 'â­',
        'price': 'ğŸ’°',
        'avgPrice': 'ğŸ’°',
        'type': 'ğŸ·ï¸',
        'category': 'ğŸ·ï¸',
        'tags': 'ğŸ”–',
        'description': 'ğŸ“',
        'phone': 'ğŸ“',
        'tel': 'ğŸ“',
        'openTime': 'ğŸ•',
        'businessHours': 'ğŸ•'
    }
    
    for key, value in item_dict.items():
        if key == 'name':
            continue  # name å·²ç»åœ¨æ ‡é¢˜ä¸­æ˜¾ç¤º
        
        icon = icon_map.get(key, 'â€¢')
        
        if key == 'rating' and value:
            stars = "â­" * int(float(value))
            formatted += f"{icon} **{key}**: {value} {stars}\n\n"
        elif key == 'tags' and isinstance(value, list):
            tags_str = " Â· ".join(str(t) for t in value)
            formatted += f"{icon} **{key}**: {tags_str}\n\n"
        elif value:
            formatted += f"{icon} **{key}**: {value}\n\n"
    
    return formatted




def _rewrite_apt_sources(mirror_url=None):
    if not sys.platform.startswith("linux"):
        return False
    mirror = (mirror_url or os.getenv("APT_MIRROR", "")).strip()
    if mirror:
        mirror_base = mirror
        security_base = mirror
    else:
        mirror_base = "http://archive.ubuntu.com/ubuntu"
        security_base = "http://security.ubuntu.com/ubuntu"

    paths = ["/etc/apt/sources.list"]
    paths.extend(glob.glob("/etc/apt/sources.list.d/*.list"))
    changed = False
    for path in paths:
        try:
            if not os.path.exists(path):
                continue
            with open(path, "r", encoding="utf-8", errors="ignore") as f:
                content = f.read()
            new = content
            for old in (
                "http://mirrors.aliyun.com/ubuntu",
                "https://mirrors.aliyun.com/ubuntu",
                "http://archive.ubuntu.com/ubuntu",
                "https://archive.ubuntu.com/ubuntu",
            ):
                new = new.replace(old, mirror_base)
            for old in (
                "http://security.ubuntu.com/ubuntu",
                "https://security.ubuntu.com/ubuntu",
            ):
                new = new.replace(old, security_base)
            if new != content:
                with open(path, "w", encoding="utf-8") as f:
                    f.write(new)
                changed = True
        except Exception as e:
            print(f"Warning: failed to rewrite apt sources {path}: {e}")
    return changed


def _run_apt_get(args, env):
    return subprocess.run(
        ["apt-get"] + args,
        check=True,
        env=env,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
    )


def _parse_node_major(version_output):
    if not version_output:
        return None
    match = re.search(r"v?(\d+)\.", version_output.strip())
    if not match:
        return None
    try:
        return int(match.group(1))
    except Exception:
        return None

def _node_version_ok(result, min_major):
    if result is None or result.returncode != 0:
        return False
    major = _parse_node_major(result.stdout)
    if major is None:
        return False
    if major < min_major:
        print(f"Warning: Node.js v{major} detected, but >= {min_major} is required.")
        return False
    return True

def _detect_node_dist():
    machine = platform.machine().lower()
    if machine in ("x86_64", "amd64"):
        return "linux-x64"
    if machine in ("aarch64", "arm64"):
        return "linux-arm64"
    if machine.startswith("armv7"):
        return "linux-armv7l"
    if machine.startswith("armv6"):
        return "linux-armv6l"
    return None

def _get_node_version(min_major):
    env_ver = os.getenv("NODE_VERSION", "").strip()
    if env_ver:
        return env_ver.lstrip("v")
    index_urls = []
    env_index = os.getenv("NODE_INDEX_URL", "").strip()
    if env_index:
        index_urls.append(env_index)
    index_urls += [
        "https://nodejs.org/dist/index.json",
        "https://npmmirror.com/mirrors/node/index.json",
    ]
    for url in index_urls:
        try:
            resp = requests.get(url, timeout=10)
            if resp.status_code != 200:
                continue
            data = resp.json()
            for entry in data:
                ver = (entry.get("version") or "").lstrip("v")
                if ver.split(".")[0] == str(min_major):
                    return ver
        except Exception:
            continue
    fallback = {
        18: "18.20.4",
        20: "20.11.1",
        22: "22.3.0",
    }
    return fallback.get(min_major, f"{min_major}.20.0")

def _download_file(url, dest, timeout=30):
    resp = None
    try:
        resp = requests.get(url, stream=True, timeout=timeout)
        if resp.status_code != 200:
            return False
        with open(dest, "wb") as f:
            for chunk in resp.iter_content(chunk_size=1024 * 1024):
                if chunk:
                    f.write(chunk)
        return True
    except Exception as e:
        print(f"Warning: download failed: {e}")
        return False
    finally:
        if resp is not None:
            try:
                resp.close()
            except Exception:
                pass

def _install_node_from_tarball(env, min_major):
    dist = _detect_node_dist()
    if not dist:
        print("Warning: unsupported architecture for Node.js binary")
        return False
    version = _get_node_version(min_major)
    if not version:
        print("Warning: unable to determine Node.js version")
        return False
    base_candidates = []
    env_base = os.getenv("NODE_DIST_BASE", "").strip()
    if env_base:
        base_candidates.append(env_base.rstrip("/"))
    base_candidates += [
        "https://nodejs.org/dist",
        "https://npmmirror.com/mirrors/node",
    ]
    cache_root = os.path.join(os.path.dirname(__file__), ".node")
    os.makedirs(cache_root, exist_ok=True)
    target_dir = os.path.join(cache_root, f"node-v{version}-{dist}")
    node_bin = os.path.join(target_dir, "bin", "node")
    if os.path.exists(node_bin):
        env["PATH"] = f"{os.path.join(target_dir, 'bin')}{os.pathsep}{env.get('PATH', '')}"
        env["NODE_HOME"] = target_dir
        return True
    tar_name = f"node-v{version}-{dist}.tar.xz"
    for base in base_candidates:
        url = f"{base}/v{version}/{tar_name}"
        print(f"Downloading Node.js from {url}...")
        try:
            with tempfile.TemporaryDirectory() as tmpdir:
                tar_path = os.path.join(tmpdir, tar_name)
                if not _download_file(url, tar_path):
                    continue
                try:
                    with tarfile.open(tar_path, "r:xz") as tf:
                        tf.extractall(path=cache_root)
                except Exception as e:
                    print(f"Warning: failed to extract Node.js tarball: {e}")
                    continue
        except Exception as e:
            print(f"Warning: download/extract failed: {e}")
            continue
        if os.path.exists(node_bin):
            env["PATH"] = f"{os.path.join(target_dir, 'bin')}{os.pathsep}{env.get('PATH', '')}"
            env["NODE_HOME"] = target_dir
            return True
    return False

def _install_node(env, min_major):
    if not sys.platform.startswith("linux"):
        return False
    env.setdefault("DEBIAN_FRONTEND", "noninteractive")
    force_tarball = os.getenv("FORCE_NODE_TARBALL", "").strip().lower() in ("1", "true", "yes", "y")
    skip_apt = os.getenv("SKIP_APT", "").strip().lower() in ("1", "true", "yes", "y")
    if force_tarball or skip_apt:
        print("Skipping apt-get; forcing Node.js tarball install.")
        return _install_node_from_tarball(env, min_major)
    if shutil.which("apt-get"):
        try:
            try:
                _run_apt_get(["update"], env)
            except subprocess.CalledProcessError as e:
                err_tail = ""
                if getattr(e, "stderr", None):
                    err_tail = e.stderr.strip().splitlines()[-1]
                if err_tail:
                    print(f"Warning: apt-get update failed: {err_tail}")
                else:
                    print(f"Warning: apt-get update failed: {e}")
                if _rewrite_apt_sources():
                    print("Retrying apt-get update after rewriting sources...")
                    _run_apt_get(["update"], env)
                else:
                    raise

            try:
                _run_apt_get(["install", "-y", "ca-certificates", "curl", "gnupg"], env)
            except subprocess.CalledProcessError as e:
                err_tail = ""
                if getattr(e, "stderr", None):
                    err_tail = e.stderr.strip().splitlines()[-1]
                if err_tail:
                    print(f"Warning: apt-get install prereqs failed: {err_tail}")
                else:
                    print(f"Warning: apt-get install prereqs failed: {e}")

            if shutil.which("curl"):
                setup_url = f"https://deb.nodesource.com/setup_{min_major}.x"
                try:
                    subprocess.run(
                        ["bash", "-c", f"curl -fsSL {setup_url} | bash -"],
                        check=True,
                        env=env,
                        stdout=subprocess.PIPE,
                        stderr=subprocess.PIPE,
                        text=True,
                    )
                except subprocess.CalledProcessError as e:
                    err_tail = ""
                    if getattr(e, "stderr", None):
                        err_tail = e.stderr.strip().splitlines()[-1]
                    if err_tail:
                        print(f"Warning: NodeSource setup failed: {err_tail}")
                    else:
                        print(f"Warning: NodeSource setup failed: {e}")

            _run_apt_get(["install", "-y", "nodejs", "npm"], env)
            return True
        except subprocess.CalledProcessError as e:
            err_tail = ""
            if getattr(e, "stderr", None):
                err_tail = e.stderr.strip().splitlines()[-1]
            if err_tail:
                print(f"Warning: apt-get install failed: {err_tail}")
            else:
                print(f"Warning: apt-get install failed: {e}")
        except Exception as e:
            print(f"Warning: apt-get install failed: {e}")
    print("Falling back to Node.js binary tarball install...")
    return _install_node_from_tarball(env, min_major)


def _run_npm(args, env, cwd):
    return subprocess.run(
        ["npm"] + args,
        check=True,
        env=env,
        cwd=cwd,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
    )


def _ensure_node_modules(backend_dir, env):
    if os.getenv("SKIP_NPM_INSTALL", "").strip().lower() in ("1", "true", "yes", "y"):
        return True

    package_json = os.path.join(backend_dir, "package.json")
    if not os.path.exists(package_json):
        print("Warning: package.json not found; skipping npm install")
        return True

    node_modules = os.path.join(backend_dir, "node_modules")
    express_dir = os.path.join(node_modules, "express")
    if os.path.exists(express_dir):
        return True

    npm_registry = os.getenv("NPM_REGISTRY", "").strip()
    if not npm_registry:
        npm_registry = os.getenv("NPM_CONFIG_REGISTRY", "").strip()
    if not npm_registry:
        npm_registry = "https://registry.npmmirror.com"
    env["NPM_CONFIG_REGISTRY"] = npm_registry

    lock_path = os.path.join(backend_dir, "package-lock.json")
    cmd = ["ci", "--omit=dev", "--no-audit", "--no-fund"] if os.path.exists(lock_path) else ["install", "--omit=dev", "--no-audit", "--no-fund"]
    try:
        print(f"Installing backend dependencies via npm ({' '.join(cmd)})...")
        _run_npm(cmd, env, backend_dir)
        return True
    except subprocess.CalledProcessError as e:
        err_tail = ""
        if getattr(e, "stderr", None):
            err_tail = e.stderr.strip().splitlines()[-1] if e.stderr.strip() else ""
        if err_tail:
            print(f"Warning: npm ci failed: {err_tail}")
        else:
            print(f"Warning: npm ci failed: {e}")
        try:
            print("Retrying npm install...")
            _run_npm(["install", "--omit=dev", "--no-audit", "--no-fund"], env, backend_dir)
            return True
        except Exception as e2:
            print(f"Warning: npm install failed: {e2}")
            return False
    except FileNotFoundError:
        print("Warning: npm not found in PATH")
        return False
def start_backend_service():
    """å¯åŠ¨ Node.js åç«¯æœåŠ¡"""
    global backend_ready, backend_failed
    try:
        # è®¾ç½®ç¯å¢ƒå˜é‡
        env = os.environ.copy()
        # ä¸ºåç«¯æœåŠ¡æŒ‡å®šä¸€ä¸ªä¸åŒçš„ç«¯å£ï¼Œé¿å…ä¸Gradioå†²çª
        env["PORT"] = "13579"  # æ”¹ä¸º13579ç«¯å£ï¼Œé¿å¼€8080
        env["HOST"] = "127.0.0.1" # åªç›‘å¬æœ¬åœ°å›ç¯ï¼Œé¿å…è¢«å¤–éƒ¨ä»£ç†æ‹¦æˆª

        
        # è®¾ç½®æ•°æ®åº“ç¯å¢ƒå˜é‡ä¸ºé»˜è®¤å€¼ï¼ˆé¿å…æ•°æ®åº“è¿æ¥é”™è¯¯ï¼‰
        env["DB_HOST"] = env.get("DB_HOST", "127.0.0.1")
        env["DB_USER"] = env.get("DB_USER", "root")
        env["DB_PORT"] = env.get("DB_PORT", "3306")
        env["DB_PASSWORD"] = env.get("DB_PASSWORD", "")
        env["DB_NAME"] = env.get("DB_NAME", "hipong")
        
        # ç¡®ä¿APIå¯†é’¥ç¯å¢ƒå˜é‡è¢«ä¼ é€’
        env["DEEPSEEK_API_KEY"] = os.getenv("DEEPSEEK_API_KEY", "")
        env["AMAP_API_KEY"] = os.getenv("AMAP_API_KEY", "")
        env["DOUYIN_APPID"] = os.getenv("DOUYIN_APPID", "")
        env["DOUYIN_SECRET"] = os.getenv("DOUYIN_SECRET", "")
        env["DOUYIN_SANDBOX"] = os.getenv("DOUYIN_SANDBOX", "true")
        
        # Ensure Node.js is available and meets minimum version.
        result = None
        try:
            result = subprocess.run(["node", "--version"], capture_output=True, text=True, timeout=10, env=env)
        except FileNotFoundError:
            result = None

        if not _node_version_ok(result, NODE_MIN_MAJOR):
            auto_install_raw = os.getenv("AUTO_INSTALL_NODE", "").strip().lower()
            auto_install = auto_install_raw not in ("0", "false", "no", "n")
            if not auto_install:
                print("Node.js not found; auto-install disabled by AUTO_INSTALL_NODE=0.")
                backend_failed = True
                return
            print("Node.js not found or too old. Attempting to install/upgrade...")
            if not _install_node(env, NODE_MIN_MAJOR):
                backend_failed = True
                return
            try:
                result = subprocess.run(["node", "--version"], capture_output=True, text=True, timeout=10, env=env)
            except FileNotFoundError:
                result = None
        if not _node_version_ok(result, NODE_MIN_MAJOR):
            print("Warning: Node.js is not available or version is too low")
            backend_failed = True  # ??True?????????
            return

        print(f"Starting HIPONG backend service with Node.js {result.stdout.strip()}")
        
        # æ£€æŸ¥ server.js æ˜¯å¦å­˜åœ¨ï¼ˆåœ¨å®¹å™¨ä¸­çš„æ­£ç¡®è·¯å¾„ï¼‰
        backend_dir = os.path.join(os.path.dirname(__file__), "backend")
        server_path = os.path.join(backend_dir, "server.js")
        
        print(f"Looking for server.js at: {server_path}")
        print(f"Backend directory exists: {os.path.exists(backend_dir)}")
        print(f"Server.js exists: {os.path.exists(server_path)}")
        
        if not os.path.exists(server_path):
            print(f"Warning: {server_path} not found")
            # å°è¯•åˆ—å‡º backend ç›®å½•ä¸‹çš„æ–‡ä»¶
            if os.path.exists(backend_dir):
                files = os.listdir(backend_dir)
                print(f"Files in backend directory: {files}")
            else:
                print("Backend directory does not exist!")
            backend_failed = True  # è®¾ä¸ºTrueä»¥é¿å…ç•Œé¢æ— é™ç­‰å¾…
            return

        if not _ensure_node_modules(backend_dir, env):
            backend_failed = True
            print("Backend dependencies install failed")
            return
            
        # å¯åŠ¨ Node.js æœåŠ¡å™¨
        process = subprocess.Popen(
            ["node", "server.js"],
            cwd=backend_dir,  # åœ¨ backend ç›®å½•ä¸‹è¿è¡Œ
            env=env
        )
        
        # ç­‰å¾…ä¸€æ®µæ—¶é—´è®©æœåŠ¡å¯åŠ¨
        time.sleep(15)

        if backend_healthcheck(BACKEND_BASE_URL, timeout=3):
            backend_ready = True
            print("Backend service ready")
        else:
            backend_failed = True
            print("Backend service health check failed")
        
        # ç­‰å¾…è¿›ç¨‹ç»“æŸï¼ˆä¿æŒæœåŠ¡è¿è¡Œ)
        process.wait()
        
    except subprocess.TimeoutExpired:
        print("Warning: Node.js version check timed out")
        backend_failed = True
    except FileNotFoundError:
        print("Warning: Node.js is not installed or not in PATH")
        backend_failed = True
    except Exception as e:
        print(f"Error starting Node.js backend: {e}")
        backend_failed = True

def launch_backend():
    """åœ¨åå°çº¿ç¨‹ä¸­å¯åŠ¨ Node.js æœåŠ¡"""
    try:
        backend_thread = threading.Thread(target=start_backend_service, daemon=True)
        backend_thread.start()
        return backend_thread
    except Exception as e:
        print(f"Failed to launch backend: {e}")
        global backend_failed
        backend_failed = True
        return None

# å¯åŠ¨åç«¯æœåŠ¡ï¼ˆåœ¨å•ç‹¬çš„çº¿ç¨‹ä¸­ï¼‰
print("Launching backend service...")
backend_thread = launch_backend()

def get_public_routes():
    """
    å°è¯•è®¿é—®ä¸éœ€è¦è®¤è¯çš„å…¬å…±è·¯ç”±
    """
    print("å°è¯•è®¿é—®å…¬å…±è·¯ç”±...")
    
    headers = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'User-Agent': 'Mozilla/5.0 (compatible; HIPONG App)',
        'Origin': 'http://127.0.0.1:13579',
        'Referer': 'http://127.0.0.1:13579/'
    }
    
    # æµ‹è¯•æ ¹è·¯å¾„
    try:
        response = requests.get(backend_url("/"), headers=headers, timeout=10)
        print(f"æ ¹è·¯å¾„è®¿é—®çŠ¶æ€: {response.status_code}")
        print(f"æ ¹è·¯å¾„å“åº”å†…å®¹: {response.text}")
    except Exception as e:
        print(f"æ ¹è·¯å¾„è®¿é—®å¤±è´¥: {str(e)}")
    
    # æµ‹è¯•/apiè·¯å¾„
    try:
        response = requests.get(backend_url("/api"), headers=headers, timeout=10)
        print(f"/apiè·¯å¾„è®¿é—®çŠ¶æ€: {response.status_code}")
        print(f"/apiè·¯å¾„å“åº”å†…å®¹: {response.text}")
    except Exception as e:
        print(f"/apiè·¯å¾„è®¿é—®å¤±è´¥: {str(e)}")

def get_location_coordinates(location_name):
    """
    æ ¹æ®åœ°ç‚¹åç§°è·å–ç»çº¬åº¦åæ ‡
    """
    api_key = os.getenv("AMAP_API_KEY", "c644dfe4025597410cbdf2b6de3bd8d2")
    encoded_location = urllib.parse.quote(location_name)
    url = f"https://restapi.amap.com/v3/geocode/geo?key={api_key}&address={encoded_location}"
    
    try:
        response = requests.get(url, timeout=10)
        if response.status_code == 200:
            data = response.json()
            if data.get("status") == "1" and data.get("geocodes"):
                location = data["geocodes"][0]["location"]
                if location:
                    lng, lat = location.split(",")
                    return float(lat), float(lng)
    except Exception as e:
        print(f"è·å–åæ ‡å¤±è´¥: {e}")
    
    # å¦‚æœè·å–å¤±è´¥ï¼Œè¿”å›é»˜è®¤åæ ‡ï¼ˆæ­å·ï¼‰
    return 30.2741, 120.1551

def hipong_demo(preference, types, origin, people_count, budget, max_transit_time, *partner_locations):
    """
    HIPONG åœ°ç‚¹æ¨èç³»ç»Ÿæ¼”ç¤ºå‡½æ•°
    """
    print(f"æ¥æ”¶åˆ°æ¨èè¯·æ±‚: æ´»åŠ¨åå¥½={preference}, åœ°ç‚¹ç±»å‹={types}, å‡ºå‘åœ°ç‚¹={origin}, å‚ä¸äººæ•°={people_count}, äººå‡é¢„ç®—={budget}, æœ€å¤§é€šå‹¤æ—¶é—´={max_transit_time}")
    
    global backend_ready, backend_failed

    if backend_failed:
        # Use Python fallback when Node.js backend is unavailable (ModelScope space).
        latitude, longitude = get_location_coordinates(origin or "")
        TYPE_MAP = {
            "\u9910\u996e": "050000",
            "\u4f53\u80b2\u4f11\u95f2": "080000",
            "\u8d2d\u7269": "060000",
            "\u98ce\u666f\u540d\u80dc": "110000",
            "\u79d1\u6559\u6587\u5316": "140000",
        }
        types_list = [TYPE_MAP[t] for t in (types or []) if t in TYPE_MAP]
        if not types_list:
            types_list = ["050000", "080000"]
        fallback_result = fallback_recommendation(
            preference, types_list, origin, latitude, longitude
        )
        return format_recommendation_result(fallback_result)
    
    # å¦‚æœåç«¯å°šæœªå‡†å¤‡å¥½ï¼Œç»™å‡ºæç¤º
    if not backend_ready:
        return f"## â³ ç³»ç»ŸçŠ¶æ€\n\nç³»ç»Ÿå·²æ¥æ”¶è¯·æ±‚ï¼Œåç«¯æœåŠ¡æ­£åœ¨å¯åŠ¨ä¸­...\n\n### ğŸ“‹ è¯·æ±‚ä¿¡æ¯\n\n- **æ´»åŠ¨åå¥½**: {preference}\n- **åœ°ç‚¹ç±»å‹**: {types}\n- **å‡ºå‘åœ°ç‚¹**: {origin}\n- **å‚ä¸äººæ•°**: {people_count} äºº\n- **äººå‡é¢„ç®—**: Â¥{budget}\n- **æœ€å¤§é€šå‹¤æ—¶é—´**: {max_transit_time} åˆ†é’Ÿ\n\nè¯·ç¨å€™..."
    
    # è·å–å®é™…çš„ç»çº¬åº¦åæ ‡
    latitude, longitude = get_location_coordinates(origin)
    print(f"è·å–åˆ° {origin} çš„åæ ‡: ({latitude}, {longitude})")
    
    # è·å–åŒè¡Œè€…ä½ç½®ä¿¡æ¯
    partners = []
    for i in range(int(people_count) - 1):  # å‡1æ˜¯å› ä¸ºoriginæ˜¯ç¬¬ä¸€ä¸ªç”¨æˆ·
        if i < len(partner_locations) and partner_locations[i]:
            partner_lat, partner_lng = get_location_coordinates(partner_locations[i])
            partners.append({
                "name": f"åŒè¡Œè€…{i+1}",
                "latitude": partner_lat,
                "longitude": partner_lng
            })
            print(f"è·å–åˆ°åŒè¡Œè€…{i+1} {partner_locations[i]} çš„åæ ‡: ({partner_lat}, {partner_lng})")
    
    # å°†ç±»å‹åˆ—è¡¨è½¬æ¢ä¸ºåç«¯æ‰€éœ€çš„æ ¼å¼
    # æ ¹æ®TYPE_MAPå°†ä¸­æ–‡ç±»å‹è½¬æ¢ä¸ºé«˜å¾·APIæ‰€éœ€çš„ç±»å‹ç 
    TYPE_MAP = {
        "é¤é¥®": "050000",
        "ä½“è‚²ä¼‘é—²": "080000",
        "è´­ç‰©": "060000",
        "é£æ™¯åèƒœ": "110000",
        "ç§‘æ•™æ–‡åŒ–": "140000",
    }
    
    # å°†ä¸­æ–‡ç±»å‹è½¬æ¢ä¸ºç±»å‹ç 
    types_list = [TYPE_MAP[t] for t in types if t in TYPE_MAP]
    if not types_list:
        types_list = ["050000", "080000"]  # é»˜è®¤ç±»å‹ï¼šé¤é¥®å’Œä½“è‚²ä¼‘é—²
    
    # å…ˆå°è¯•è®¿é—®å…¬å…±è·¯ç”±ï¼Œè¯Šæ–­è®¤è¯é—®é¢˜
    get_public_routes()
    
    # å°è¯•è°ƒç”¨åç«¯æœåŠ¡ - æ”¹ä¸º8080ç«¯å£
    try:
        payload = {
            "preferenceText": preference,
            "origin": {
                "name": origin,
                "latitude": latitude,
                "longitude": longitude
            },
            "partners": partners,
            "types": types_list,
            "maxTransitTime": int(max_transit_time),
            "maxBudget": int(budget) if budget else None,
            "minBudget": None
        }
        
        print(f"å‘é€è¯·æ±‚åˆ°åç«¯: {payload}")
        
        # è®¾ç½®è¯·æ±‚å¤´
        headers = {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'User-Agent': 'Mozilla/5.0 (compatible; HIPONG App)',
            'Origin': 'http://127.0.0.1:13579',
            'Referer': 'http://127.0.0.1:13579/'
        }
        
        # é¦–å…ˆå°è¯•ä¸å¸¦è®¤è¯çš„è¯·æ±‚
        print("å°è¯•ä¸å¸¦è®¤è¯çš„è¯·æ±‚...")
        response = requests.post(
            backend_url("/getInitialPoisByPrefs"),
            json=payload,
            headers=headers,
            timeout=30  # å¢åŠ è¶…æ—¶æ—¶é—´
        )
        
        print(f"åç«¯å“åº”çŠ¶æ€ç : {response.status_code}")
        print(f"åç«¯å“åº”å†…å®¹: {response.text}")
        
        if response.status_code == 200:
            result = response.json()
            print(f"åç«¯å“åº”æ•°æ®: {result}")
            
            if result.get("success"):
                rec_id = result.get("recId")
                if rec_id:
                    # å¼€å§‹è½®è¯¢æŸ¥è¯¢ç»“æœ
                    polling_attempts = 30  # æœ€å¤šé‡è¯•30æ¬¡
                    polling_interval = 5  # æ¯5ç§’æŸ¥è¯¢ä¸€æ¬¡
                    
                    print(f"è·å–åˆ°æ¨èä»»åŠ¡ID: {rec_id}")
                    
                    for i in range(polling_attempts):
                        # æŸ¥è¯¢ä»»åŠ¡çŠ¶æ€
                        status_response = requests.get(
                            backend_url(f"/recommendation-status/{rec_id}"),
                            headers=headers,
                            timeout=10
                        )
                        
                        print(f"è½®è¯¢çŠ¶æ€å“åº”: {status_response.status_code}")
                        print(f"è½®è¯¢çŠ¶æ€å†…å®¹: {status_response.text}")
                        
                        if status_response.status_code == 200:
                            status_result = status_response.json()
                            print(f"çŠ¶æ€æŸ¥è¯¢ç»“æœ: {status_result}")
                            
                            if status_result.get("success"):
                                task_status = status_result.get("taskStatus", {})
                                
                                if task_status.get("ready"):
                                    if task_status.get("success"):
                                        final_result = task_status.get("data")
                                        print(f"æˆåŠŸè·å–æ¨èç»“æœ: {final_result}")
                                        # ä½¿ç”¨ç¾åŒ–å‡½æ•°æ ¼å¼åŒ–ç»“æœ
                                        return format_recommendation_result(final_result)
                                    else:
                                        error_msg = task_status.get("error", "æœªçŸ¥é”™è¯¯")
                                        print(f"æ¨èæœåŠ¡å¤„ç†å¤±è´¥: {error_msg}")
                                        return f"## âŒ æ¨èå¤±è´¥\n\n{error_msg}"
                                else:
                                    # ä»»åŠ¡ä»åœ¨å¤„ç†ä¸­ï¼Œæ›´æ–°çŠ¶æ€ä¿¡æ¯
                                    remaining_time = (polling_attempts - i - 1) * polling_interval
                                    print(f"ä»»åŠ¡ä»åœ¨å¤„ç†ä¸­...å‰©ä½™æ—¶é—´çº¦ {remaining_time} ç§’")
                                    # ç»§ç»­è½®è¯¢
                            else:
                                print("æŸ¥è¯¢çŠ¶æ€å¤±è´¥ï¼Œå°è¯•ç»§ç»­è½®è¯¢...")
                        else:
                            print(f"çŠ¶æ€æŸ¥è¯¢å¤±è´¥ï¼ŒHTTP {status_response.status_code}")
                        
                        # ç­‰å¾…ä¸€æ®µæ—¶é—´å†æŸ¥è¯¢
                        time.sleep(polling_interval)
                    
                    print("å¤„ç†è¶…æ—¶")
                    return f"## â±ï¸ å¤„ç†è¶…æ—¶\n\n### ğŸ“‹ è¯·æ±‚ä¿¡æ¯\n\n- **æ´»åŠ¨åå¥½**: {preference}\n- **å‡ºå‘åœ°ç‚¹**: {origin}\n- **å‚ä¸äººæ•°**: {people_count} äºº\n- **äººå‡é¢„ç®—**: Â¥{budget}\n- **æœ€å¤§é€šå‹¤æ—¶é—´**: {max_transit_time} åˆ†é’Ÿ\n\nå¤„ç†æ—¶é—´è¿‡é•¿ï¼Œè¯·ç¨åå†è¯•"
                else:
                    print("åç«¯æœåŠ¡å“åº”: æœªèƒ½è·å–ä»»åŠ¡ID")
                    return f"## âŒ é”™è¯¯\n\næœªèƒ½è·å–ä»»åŠ¡ID"
            else:
                error_msg = result.get('message', 'æœªçŸ¥é”™è¯¯')
                print(f"åç«¯æœåŠ¡å“åº”: {error_msg}")
                return f"## âŒ åç«¯é”™è¯¯\n\n{error_msg}"
        elif response.status_code == 401:
            print("APIéœ€è¦è®¤è¯ï¼Œå°è¯•ç»•è¿‡è®¤è¯æˆ–ä½¿ç”¨æ¨¡æ‹Ÿtoken...")
            
            # å°è¯•æ·»åŠ ä¸€ä¸ªæ¨¡æ‹Ÿçš„è®¤è¯å¤´éƒ¨ï¼Œçœ‹æ˜¯å¦èƒ½ç»•è¿‡è®¤è¯æ£€æŸ¥
            headers['Authorization'] = 'Bearer dummy-token-for-testing'
            print("ä½¿ç”¨æ¨¡æ‹Ÿtokené‡è¯•...")
            response_retry = requests.post(
                backend_url("/getInitialPoisByPrefs"),
                json=payload,
                headers=headers,
                timeout=30
            )
            
            print(f"é‡è¯•åå“åº”çŠ¶æ€ç : {response_retry.status_code}")
            print(f"é‡è¯•åå“åº”å†…å®¹: {response_retry.text}")
            
            if response_retry.status_code == 200:
                result = response_retry.json()
                print(f"é‡è¯•åå“åº”æ•°æ®: {result}")
                if result.get("success"):
                    rec_id = result.get("recId")
                    if rec_id:
                        # å¼€å§‹è½®è¯¢æŸ¥è¯¢ç»“æœ
                        polling_attempts = 30  # æœ€å¤šé‡è¯•30æ¬¡
                        polling_interval = 5  # æ¯5ç§’æŸ¥è¯¢ä¸€æ¬¡
                        
                        print(f"è·å–åˆ°æ¨èä»»åŠ¡ID: {rec_id}")
                        
                        for i in range(polling_attempts):
                            # æŸ¥è¯¢ä»»åŠ¡çŠ¶æ€
                            status_response = requests.get(
                                backend_url(f"/recommendation-status/{rec_id}"),
                                headers=headers,
                                timeout=10
                            )
                            
                            print(f"è½®è¯¢çŠ¶æ€å“åº”: {status_response.status_code}")
                            print(f"è½®è¯¢çŠ¶æ€å†…å®¹: {status_response.text}")
                            
                            if status_response.status_code == 200:
                                status_result = status_response.json()
                                print(f"çŠ¶æ€æŸ¥è¯¢ç»“æœ: {status_result}")
                                
                                if status_result.get("success"):
                                    task_status = status_result.get("taskStatus", {})
                                    
                                    if task_status.get("ready"):
                                        if task_status.get("success"):
                                            final_result = task_status.get("data")
                                            print(f"æˆåŠŸè·å–æ¨èç»“æœ: {final_result}")
                                            # ä½¿ç”¨ç¾åŒ–å‡½æ•°æ ¼å¼åŒ–ç»“æœ
                                            return format_recommendation_result(final_result)
                                        else:
                                            error_msg = task_status.get("error", "æœªçŸ¥é”™è¯¯")
                                            print(f"æ¨èæœåŠ¡å¤„ç†å¤±è´¥: {error_msg}")
                                            return f"## âŒ æ¨èå¤±è´¥\n\n{error_msg}"
                                    else:
                                        # ä»»åŠ¡ä»åœ¨å¤„ç†ä¸­
                                        remaining_time = (polling_attempts - i - 1) * polling_interval
                                        print(f"ä»»åŠ¡ä»åœ¨å¤„ç†ä¸­...å‰©ä½™æ—¶é—´çº¦ {remaining_time} ç§’")
                                        # ç»§ç»­è½®è¯¢
                            else:
                                print(f"çŠ¶æ€æŸ¥è¯¢å¤±è´¥ï¼ŒHTTP {status_response.status_code}")
                            
                            # ç­‰å¾…ä¸€æ®µæ—¶é—´å†æŸ¥è¯¢
                            time.sleep(polling_interval)
                        
                        print("å¤„ç†è¶…æ—¶")
                        return f"## â±ï¸ å¤„ç†è¶…æ—¶\n\n### ğŸ“‹ è¯·æ±‚ä¿¡æ¯\n\n- **æ´»åŠ¨åå¥½**: {preference}\n- **å‡ºå‘åœ°ç‚¹**: {origin}\n- **å‚ä¸äººæ•°**: {people_count} äºº\n- **äººå‡é¢„ç®—**: Â¥{budget}\n- **æœ€å¤§é€šå‹¤æ—¶é—´**: {max_transit_time} åˆ†é’Ÿ\n\nå¤„ç†æ—¶é—´è¿‡é•¿ï¼Œè¯·ç¨åå†è¯•"
                    else:
                        return f"## âŒ é”™è¯¯\n\næœªèƒ½è·å–ä»»åŠ¡ID"
                else:
                    error_msg = result.get('message', 'æœªçŸ¥é”™è¯¯')
                    return f"## âŒ åç«¯é”™è¯¯\n\n{error_msg}"
            
            return f"## ğŸ”’ è®¤è¯é”™è¯¯\n\næœåŠ¡éœ€è¦è®¤è¯ (HTTP {response.status_code})"
        elif response.status_code == 404:
            print("APIæ¥å£ä¸å­˜åœ¨ï¼Œè¯·æ£€æŸ¥åç«¯è·¯ç”±é…ç½®")
            # å°è¯•å¦ä¸€ä¸ªå¯èƒ½çš„APIè·¯å¾„
            alt_response = requests.get(backend_url("/"))
            print(f"æ ¹è·¯å¾„è®¿é—®çŠ¶æ€: {alt_response.status_code}")
            print(f"æ ¹è·¯å¾„å“åº”å†…å®¹: {alt_response.text}")
            return f"## âŒ APIé”™è¯¯\n\nAPIæ¥å£æœªæ‰¾åˆ° (HTTP 404)ï¼Œè¯·æ£€æŸ¥åç«¯é…ç½®"
        else:
            print(f"åç«¯æœåŠ¡è¿”å›é”™è¯¯çŠ¶æ€ç : {response.status_code}")
            print(f"åç«¯æœåŠ¡å“åº”å†…å®¹: {response.text}")
            return f"## âŒ åç«¯é”™è¯¯\n\nHTTP {response.status_code}\n\n{response.text}"
    
    except requests.exceptions.ConnectionError:
        print("åç«¯æœåŠ¡è¿æ¥å¤±è´¥")
        return f"## âŒ è¿æ¥å¤±è´¥\n\næ— æ³•è¿æ¥åˆ°åç«¯æœåŠ¡ï¼Œè¯·æ£€æŸ¥æœåŠ¡æ˜¯å¦æ­£å¸¸è¿è¡Œ"
    except requests.exceptions.ReadTimeout:
        print("è¯·æ±‚è¶…æ—¶")
        return f"## â±ï¸ è¯·æ±‚è¶…æ—¶\n\nåç«¯æœåŠ¡å“åº”è¶…æ—¶ï¼Œè¯·ç¨åå†è¯•"
    except Exception as e:
        print(f"å¤„ç†è¯·æ±‚å¼‚å¸¸: {str(e)}")
        return f"## âŒ ç³»ç»Ÿé”™è¯¯\n\n{str(e)}"


def format_team_activity(activity, index=None):
    """æ ¼å¼åŒ–å•ä¸ªå›¢å»ºæ´»åŠ¨"""
    if not isinstance(activity, dict):
        return f"- {activity}\n"

    title = activity.get("name") or activity.get("title") or "æ´»åŠ¨"
    time_info = activity.get("time") or activity.get("timeRange") or ""
    address = activity.get("address") or ""
    activity_type = activity.get("type") or ""
    cost = activity.get("cost") or activity.get("perCapitaCost") or ""
    desc = activity.get("description") or ""

    heading = f"### {index}. {title}\n" if index is not None else f"### {title}\n"
    lines = [heading]

    if isinstance(time_info, dict):
        start = time_info.get("start") or time_info.get("from") or ""
        end = time_info.get("end") or time_info.get("to") or ""
        time_info = f"{start}-{end}".strip("-")

    if time_info:
        lines.append(f"- â° æ—¶é—´: {time_info}\n")
    if address:
        lines.append(f"- ğŸ“ åœ°å€: {address}\n")
    if activity_type:
        lines.append(f"- ğŸ·ï¸ ç±»å‹: {activity_type}\n")
    if cost and cost != "æš‚æ— ":
        lines.append(f"- ğŸ’° äººå‡: {cost}\n")
    if desc:
        lines.append(f"- ğŸ“ è¯´æ˜: {desc}\n")

    travel = activity.get("travel") or {}
    travel_lines = []
    for mode, label in (("driving", "é©¾è½¦"), ("transit", "å…¬äº¤"), ("walking", "æ­¥è¡Œ")):
        info = None
        if isinstance(travel.get(mode), dict):
            info = travel.get(mode)
        elif isinstance(travel.get("allInfo"), dict) and isinstance(travel["allInfo"].get(mode), dict):
            info = travel["allInfo"].get(mode)
        if info:
            duration = info.get("duration") or info.get("time")
            distance = info.get("distance")
            seg = label
            if duration:
                seg += f" {duration}"
            if distance:
                seg += f" / {distance}"
            travel_lines.append(seg)

    if travel_lines:
        lines.append(f"- ğŸš— äº¤é€š: {' | '.join(travel_lines)}\n")
    else:
        walking = travel.get("walkingDistance") or travel.get("walking")
        driving = travel.get("drivingDistance") or travel.get("driving")
        transit = travel.get("transitDistance") or travel.get("transit")
        legacy = []
        if walking:
            legacy.append(f"æ­¥è¡Œ {walking}")
        if driving:
            legacy.append(f"é©¾è½¦ {driving}")
        if transit:
            legacy.append(f"å…¬äº¤ {transit}")
        if legacy:
            lines.append(f"- ğŸš— äº¤é€š: {' | '.join(legacy)}\n")

    return "".join(lines) + "\n"


def format_teamplan_result(result_data):
    """ç¾åŒ–å›¢å»ºæ–¹æ¡ˆç»“æœæ˜¾ç¤º"""
    if isinstance(result_data, str):
        try:
            result_data = json.loads(result_data)
        except Exception:
            return result_data

    if not isinstance(result_data, dict):
        return str(result_data)

    title = result_data.get("title") or result_data.get("name") or "å›¢å»ºæ–¹æ¡ˆ"
    formatted = f"# ğŸ‰ å›¢å»ºæ–¹æ¡ˆ\n\n## {title}\n\n"

    budget_info = result_data.get("budgetInfo") or {}
    if budget_info:
        formatted += "## ğŸ’° é¢„ç®—ä¿¡æ¯\n\n"
        per_capita = budget_info.get("perCapitaCost") or budget_info.get("totalPerCapitaCost")
        total_budget = budget_info.get("totalBudget")
        hotel_cost = budget_info.get("hotelCost")
        activity_count = budget_info.get("activityCount")
        total_cost = budget_info.get("totalCost")

        if per_capita is not None:
            formatted += f"- äººå‡é¢„ç®—: Â¥{per_capita}\n"
        if total_budget is not None:
            formatted += f"- æ€»é¢„ç®—: Â¥{total_budget}\n"
        if total_cost is not None:
            formatted += f"- æ´»åŠ¨æ€»èŠ±è´¹(äººå‡): Â¥{total_cost}\n"
        if hotel_cost:
            formatted += f"- é…’åº—å‡ä»·(äººå‡): Â¥{hotel_cost}\n"
        if activity_count:
            formatted += f"- æ´»åŠ¨æ•°é‡: {activity_count}\n"
        formatted += "\n"

    hotel = result_data.get("hotel")
    if hotel:
        formatted += "## ğŸ¨ ä½å®¿å®‰æ’\n\n"
        if hotel.get("name"):
            formatted += f"- é…’åº—: {hotel.get('name')}\n"
        if hotel.get("address"):
            formatted += f"- åœ°å€: {hotel.get('address')}\n"
        if hotel.get("checkin") or hotel.get("checkout"):
            formatted += f"- å…¥ä½/é€€æˆ¿: {hotel.get('checkin', '')} / {hotel.get('checkout', '')}\n"
        if hotel.get("cost"):
            formatted += f"- è´¹ç”¨: {hotel.get('cost')}\n"
        if hotel.get("description"):
            formatted += f"- è¯´æ˜: {hotel.get('description')}\n"
        formatted += "\n"

    if result_data.get("isMultiDay") and result_data.get("days"):
        formatted += "## ğŸ—ºï¸ è¡Œç¨‹å®‰æ’\n\n"
        for day in result_data.get("days", []):
            day_label = day.get("day") or ""
            formatted += f"### ç¬¬{day_label}å¤©\n\n"
            activities = day.get("activities") or []
            if not activities:
                formatted += "- æš‚æ— æ´»åŠ¨\n\n"
                continue
            for idx, activity in enumerate(activities, 1):
                formatted += format_team_activity(activity, idx)
    else:
        activities = result_data.get("activities") or []
        formatted += "## ğŸ—ºï¸ è¡Œç¨‹å®‰æ’\n\n"
        if not activities:
            formatted += "æš‚æ— æ´»åŠ¨å®‰æ’\n\n"
        else:
            for idx, activity in enumerate(activities, 1):
                formatted += format_team_activity(activity, idx)

    return formatted


def teamplan_demo(
    plan_name,
    people_count,
    budget_min,
    budget_max,
    budget_mode,
    start_date,
    end_date,
    start_time,
    end_time,
    start_location,
    distance_km,
    max_transit_time,
    taxi_time,
    other_notes,
):
    """å›¢å»ºæ–¹æ¡ˆç”Ÿæˆæ¼”ç¤ºå‡½æ•°"""
    print(
        "æ¥æ”¶åˆ°å›¢å»ºè§„åˆ’è¯·æ±‚:",
        plan_name,
        people_count,
        budget_min,
        budget_max,
        budget_mode,
        start_location,
    )

    global backend_ready, backend_failed

    if backend_failed:
        if not plan_name:
            plan_name = "Team Building Plan"
        try:
            people_count = int(people_count or 1)
        except Exception:
            people_count = 1
        people_count = max(1, people_count)

        today_str = date.today().isoformat()
        start_date = start_date or today_str
        end_date = end_date or start_date
        start_time = start_time or "09:00"
        end_time = end_time or "18:00"

        try:
            budget_min_val = float(budget_min) if budget_min is not None else 0
            budget_max_val = float(budget_max) if budget_max is not None else budget_min_val
        except Exception:
            budget_min_val = 0
            budget_max_val = 0

        if budget_max_val < budget_min_val:
            budget_min_val, budget_max_val = budget_max_val, budget_min_val

        if budget_mode == "\u603b\u9884\u7b97":
            per_min = budget_min_val / people_count if people_count else budget_min_val
            per_max = budget_max_val / people_count if people_count else budget_max_val
        else:
            per_min = budget_min_val
            per_max = budget_max_val

        latitude, longitude = get_location_coordinates(start_location or "")
        fallback_plan = fallback_teamplan(
            plan_name,
            people_count,
            [per_min, per_max],
            start_time,
            end_time,
            start_location,
            latitude,
            longitude,
        )
        return format_teamplan_result(fallback_plan)

    if not backend_ready:
        return "## â³ ç³»ç»ŸçŠ¶æ€\n\nåç«¯æœåŠ¡æ­£åœ¨å¯åŠ¨ä¸­ï¼Œè¯·ç¨å€™å†è¯•ã€‚"

    if not start_location:
        return "## âš ï¸ å‚æ•°ç¼ºå¤±\n\nè¯·å¡«å†™å‡ºå‘åœ°ç‚¹ã€‚"

    if not plan_name:
        plan_name = "å›¢å»ºæ–¹æ¡ˆ"

    try:
        people_count = int(people_count or 1)
    except Exception:
        people_count = 1
    people_count = max(1, people_count)

    today_str = date.today().isoformat()
    start_date = start_date or today_str
    end_date = end_date or start_date
    start_time = start_time or "09:00"
    end_time = end_time or "18:00"

    try:
        budget_min_val = float(budget_min) if budget_min is not None else 0
        budget_max_val = float(budget_max) if budget_max is not None else budget_min_val
    except Exception:
        budget_min_val = 0
        budget_max_val = 0

    if budget_max_val < budget_min_val:
        budget_min_val, budget_max_val = budget_max_val, budget_min_val

    if budget_mode == "æ€»é¢„ç®—":
        per_min = budget_min_val / people_count if people_count else budget_min_val
        per_max = budget_max_val / people_count if people_count else budget_max_val
    else:
        per_min = budget_min_val
        per_max = budget_max_val

    if per_max and per_max != per_min:
        budget_str = f"{int(per_min)}-{int(per_max)}"
    else:
        budget_str = str(int(per_min or per_max or 0))

    latitude, longitude = get_location_coordinates(start_location)
    start_location_coords = f"{longitude},{latitude}"

    payload = {
        "name": plan_name,
        "people": people_count,
        "budget": budget_str,
        "timeRange": {"start": start_time, "end": end_time},
        "dateRange": {"start": start_date, "end": end_date},
        "needAccommodation": start_date != end_date,
        "startLocation": start_location,
        "startLocationCoords": start_location_coords,
        "distance": int(distance_km or 10),
        "maxTransitTime": int(max_transit_time or 60),
        "taxiTime": int(taxi_time or 30),
    }
    if other_notes:
        payload["personalNeeds"] = other_notes

    headers = {
        "Content-Type": "application/json",
        "Accept": "application/json",
        "User-Agent": "Mozilla/5.0 (compatible; HIPONG App)",
        "Origin": "http://127.0.0.1:13579",
        "Referer": "http://127.0.0.1:13579/",
    }

    try:
        response = requests.post(
            backend_url("/api/plan-teambuilding"),
            json=payload,
            headers=headers,
            timeout=30,
        )

        if response.status_code != 200:
            return f"## âŒ åç«¯é”™è¯¯\n\nHTTP {response.status_code}\n\n{response.text}"

        result = response.json()
        if not result.get("success") or not result.get("planId"):
            return f"## âŒ ç”Ÿæˆå¤±è´¥\n\n{result.get('message', 'æœªçŸ¥é”™è¯¯')}"

        plan_id = result["planId"]
        polling_attempts = 30
        polling_interval = 5

        for i in range(polling_attempts):
            status_response = requests.get(
                backend_url(f"/api/plan-status/{plan_id}"),
                headers=headers,
                timeout=10,
            )

            if status_response.status_code == 200:
                status_result = status_response.json()
                if status_result.get("success"):
                    if status_result.get("ready"):
                        if status_result.get("planSuccess"):
                            return format_teamplan_result(status_result.get("data"))
                        return f"## âŒ ç”Ÿæˆå¤±è´¥\n\n{status_result.get('error', 'æœªçŸ¥é”™è¯¯')}"
            time.sleep(polling_interval)

        return "## â±ï¸ å¤„ç†è¶…æ—¶\n\nå›¢å»ºæ–¹æ¡ˆç”Ÿæˆè€—æ—¶è¾ƒé•¿ï¼Œè¯·ç¨åå†è¯•ã€‚"

    except requests.exceptions.ConnectionError:
        return "## âŒ è¿æ¥å¤±è´¥\n\næ— æ³•è¿æ¥åˆ°åç«¯æœåŠ¡ï¼Œè¯·ç¡®è®¤æœåŠ¡æ˜¯å¦å·²å¯åŠ¨ã€‚"
    except requests.exceptions.ReadTimeout:
        return "## â±ï¸ è¯·æ±‚è¶…æ—¶\n\nåç«¯æœåŠ¡å“åº”è¶…æ—¶ï¼Œè¯·ç¨åå†è¯•ã€‚"
    except Exception as e:
        return f"## âŒ ç³»ç»Ÿé”™è¯¯\n\n{str(e)}"

# å®šä¹‰CSSæ ·å¼ï¼Œç®€åŒ–ç‰ˆ
custom_css = """
    .container {
        max-width: 600px;
        margin: auto;
        padding: 20px;
    }
    .input-group {
        margin: 10px 0;
    }
    .button-row {
        display: flex;
        gap: 10px;
        margin-top: 20px;
    }
"""

# åˆ›å»º Gradio ç•Œé¢ - æ·»åŠ  Tab åˆ‡æ¢
with gr.Blocks(title="HIPONG æ™ºèƒ½å›¢å»ºä¸ç¢°é¢ç³»ç»Ÿ", css=custom_css) as demo:
    gr.Markdown("# HIPONG æ™ºèƒ½å›¢å»ºä¸ç¢°é¢ç³»ç»Ÿ")
    gr.Markdown("åœ¨ä¸Šæ–¹åˆ‡æ¢ç¢°é¢åœ°ç‚¹æ¨èæˆ–å›¢å»ºç­–åˆ’")

    with gr.Tabs():
        with gr.Tab("ç¢°é¢åœ°ç‚¹æ¨è"):
            with gr.Column():
                gr.Markdown("**æ´»åŠ¨åå¥½**")
                preference = gr.Textbox(placeholder="è¯·ç”¨ä¸€å¥è¯æè¿°æ‚¨çš„åå¥½ï¼Œä¾‹å¦‚ï¼šç¾é£Ÿæ¢ç´¢ã€æˆ·å¤–è¿åŠ¨")
                gr.Markdown("**ç›®çš„åœ°ç±»å‹**")
                types = gr.CheckboxGroup(choices=["é¤é¥®", "ä½“è‚²ä¼‘é—²", "è´­ç‰©", "é£æ™¯åèƒœ", "ç§‘æ•™æ–‡åŒ–"], value=["é¤é¥®", "ä½“è‚²ä¼‘é—²"])
                gr.Markdown("**å‡ºå‘åœ°ç‚¹**")
                origin = gr.Textbox(placeholder="ä¾‹å¦‚ï¼šæ­å·å¸‚è¥¿æ¹–åŒº")
                gr.Markdown("**å‚ä¸äººæ•°**")
                people_count = gr.Slider(1, 20, value=1, step=1)
                gr.Markdown("**äººå‡é¢„ç®—ï¼ˆå…ƒï¼‰**")
                budget = gr.Number(value=200)
                gr.Markdown("**æœ€å¤§é€šå‹¤æ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰**")
                max_transit_time = gr.Slider(10, 120, value=60, step=10)

                partner_locations = []
                for i in range(19):
                    partner_locations.append(
                        gr.Textbox(
                            visible=False,
                            label=f"åŒè¡Œè€…{i+1}å‡ºå‘åœ°ç‚¹",
                            placeholder="ä¾‹å¦‚ï¼šåŒ—äº¬å¸‚æœé˜³åŒº",
                        )
                    )

                generate_btn = gr.Button("ç”Ÿæˆæ¨è", variant="primary", size="lg")
                output = gr.Markdown(label="æ¨èç»“æœ")

                def update_partner_inputs(count):
                    count = int(count)
                    partner_inputs = []
                    for i in range(19):
                        partner_inputs.append(gr.update(visible=i < count - 1))
                    return partner_inputs

                people_count.change(
                    fn=update_partner_inputs,
                    inputs=[people_count],
                    outputs=partner_locations,
                )

                def process_with_loading(preference, types, origin, people_count, budget, max_transit_time, *partner_locs):
                    yield "## â³ æ­£åœ¨å¤„ç†æ‚¨çš„è¯·æ±‚...\n\nç³»ç»Ÿæ­£åœ¨ä¸ºæ‚¨ç”Ÿæˆæ¨èï¼Œè¯·ç¨å€™..."
                    result = hipong_demo(preference, types, origin, people_count, budget, max_transit_time, *partner_locs)
                    yield result

                generate_btn.click(
                    fn=process_with_loading,
                    inputs=[preference, types, origin, people_count, budget, max_transit_time] + partner_locations,
                    outputs=output,
                )

        with gr.Tab("å›¢å»ºç­–åˆ’"):
            with gr.Column():
                gr.Markdown("**å›¢å»ºè®¡åˆ’åç§°**")
                plan_name = gr.Textbox(placeholder="ä¾‹å¦‚ï¼šå‘¨æœ«å›¢å»ºÂ·æ­å·")

                gr.Markdown("**å‚ä¸äººæ•°**")
                team_people = gr.Slider(2, 50, value=10, step=1)

                gr.Markdown("**é¢„ç®—æ¨¡å¼**")
                budget_mode = gr.Radio(choices=["äººå‡é¢„ç®—", "æ€»é¢„ç®—"], value="äººå‡é¢„ç®—")

                gr.Markdown("**é¢„ç®—èŒƒå›´ï¼ˆå…ƒï¼‰**")
                team_budget_min = gr.Number(value=200, label="æœ€ä½é¢„ç®—")
                team_budget_max = gr.Number(value=400, label="æœ€é«˜é¢„ç®—")

                gr.Markdown("**æ´»åŠ¨æ—¥æœŸ**")
                team_start_date = gr.Textbox(value=date.today().isoformat(), label="å¼€å§‹æ—¥æœŸ (YYYY-MM-DD)")
                team_end_date = gr.Textbox(value=date.today().isoformat(), label="ç»“æŸæ—¥æœŸ (YYYY-MM-DD)")

                gr.Markdown("**æ´»åŠ¨æ—¶é—´**")
                team_start_time = gr.Textbox(value="09:00", label="å¼€å§‹æ—¶é—´ (HH:MM)")
                team_end_time = gr.Textbox(value="18:00", label="ç»“æŸæ—¶é—´ (HH:MM)")

                gr.Markdown("**å‡ºå‘åœ°ç‚¹**")
                team_start_location = gr.Textbox(placeholder="ä¾‹å¦‚ï¼šæ­å·å¸‚è¥¿æ¹–åŒº")

                gr.Markdown("**è·ç¦»èŒƒå›´ï¼ˆå…¬é‡Œï¼‰**")
                team_distance = gr.Slider(1, 30, value=10, step=1)

                gr.Markdown("**é€šå‹¤é™åˆ¶**")
                team_max_transit = gr.Slider(10, 120, value=60, step=5, label="å…¬å…±äº¤é€šæ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰")
                team_taxi_time = gr.Slider(10, 120, value=30, step=5, label="æ‰“è½¦æ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰")

                gr.Markdown("**ä¸ªæ€§åŒ–éœ€æ±‚**")
                team_notes = gr.Textbox(lines=3, placeholder="ä¾‹å¦‚ï¼šæƒ³è¦æˆ·å¤–æ´»åŠ¨æˆ–æœ‰è¹¦åºŠçš„åœºåœ°")

                team_generate_btn = gr.Button("ç”Ÿæˆå›¢å»ºæ–¹æ¡ˆ", variant="primary", size="lg")
                team_output = gr.Markdown(label="å›¢å»ºæ–¹æ¡ˆç»“æœ")

                def process_teamplan_with_loading(
                    plan_name,
                    people_count,
                    budget_min,
                    budget_max,
                    budget_mode,
                    start_date,
                    end_date,
                    start_time,
                    end_time,
                    start_location,
                    distance_km,
                    max_transit_time,
                    taxi_time,
                    other_notes,
                ):
                    yield "## â³ æ­£åœ¨ç”Ÿæˆå›¢å»ºæ–¹æ¡ˆ...\n\nè¯·ç¨å€™ï¼Œç³»ç»Ÿæ­£åœ¨è§„åˆ’æ´»åŠ¨ã€‚"
                    result = teamplan_demo(
                        plan_name,
                        people_count,
                        budget_min,
                        budget_max,
                        budget_mode,
                        start_date,
                        end_date,
                        start_time,
                        end_time,
                        start_location,
                        distance_km,
                        max_transit_time,
                        taxi_time,
                        other_notes,
                    )
                    yield result

                team_generate_btn.click(
                    fn=process_teamplan_with_loading,
                    inputs=[
                        plan_name,
                        team_people,
                        team_budget_min,
                        team_budget_max,
                        budget_mode,
                        team_start_date,
                        team_end_date,
                        team_start_time,
                        team_end_time,
                        team_start_location,
                        team_distance,
                        team_max_transit,
                        team_taxi_time,
                        team_notes,
                    ],
                    outputs=team_output,
                )

if __name__ == "__main__":
    demo.launch(server_name="0.0.0.0", server_port=13579, share=False)
